# Объектно-ориентированное программирование

**Тассов Кирилл Леонидович**

## Лекция 1

### Структурное программирование

* Нисходящая разработка
* Использование базовых логических структур
* Сквозной структурный контроль

`вход → f → выход`<br>
Мы думаем что они делают, а не как они это делают.

Разработка разбивает на подзадачи (↓)<br>
Логика совмещает (↑)<br>
Данные приблизить к действию (↓)

#### Что дает эта технология

* Логические ошибки исправляются на ранних стадиях
* За счет упрощения абстракции упрощается написание кода
* Повышается надежность программного продукта
* Повторное использование кода
* Плавное распределение ресурсов при разработке ПО
* Упрощается сопровождение кода
* Возникает много естественных контрольных точек

## Лекция 2

### Инкапсуляция

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали 
реализации от пользователя.

Внесение изменений в написанный код - это понижение надежности

### Наследование

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциольностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

### Типы взаимодействий по Хоару

1. Синхронное взаимодействие *(процессорное)*
2. Событийное взаимодействие *(асинхронное)*

**Объект** - конкретная реализация какого-либо понятия, обладающая характеристиками состояния, поведения, индивидуальности.

* __Состояние__ - один из возможных варианта существования объекта
* __Поведение__ - описание объекта в терминах изменения его состояний и передачи сообщений данных в процессе воздействия или под воздействием других объектов
* __Индивидуальность__ - сущность объекта, отличающего его от других объектов

### Модель состояний Мура

Формировать жизненный цикл объекта

1. Выделяем множество состояний в которых может находится объект
2. Выделяем множество событий на которые может реагировать объект
3. Правило перехода *(когда происходит определенное действие, в какое состояние объект перейдет)*
4. Действия состояния *(то, что должно выполниться в результате возникновения события)*

### Роли объектов

1. Реальные объекты
2. Роли *(абстракции целей обозначенных человеком)*
3. Инциденты как объект *(абстракция чего-то случившегося)*
4. Объекты взаимодействия *(оъекты получаемые из отношений между другими объектами)*
5. Объекты спецификации *(для представления правил, стандартов, критериев)*

### Отношения между объектами

1. Использование *(старшинства)*
	* Воздействие *(активный объект)*
	* Исполнение *(только подвержен воздействию других обектов, пассивный объект)*
	* Посредничество *(может выступать в обоих ролях)*
2. Включений *(один объект включает в себя другой)*

### Классы

Это такая абстракция множества предметов реального мира, что все эти предметы обладают одними и теми же характеристиками и подчинены и согласовываются с одними и тем же набором правил и поведений.

#### Отношения 

1. Наследование
2. Использование на уровне классов
3. Включения
4. Мета-класс

**Домен** - отдельный реальный, гипотетический или абстрактный мир, населенный набором объектов, которые ведут себя характерными для домена правилами поведения 

Класс в одном домене не требует нахождения класса в другом домене

## Лекция 3

**Объявление** - сколько угодно<br>
**Определение** - только один раз

### Ссылка

Ни тип данных, ни данное. Это еще одно имя или alias какого-то данного.

```cpp
int i;
int& ai = i;
ai = 1; // i = 1
```

### Перегрузка функций

Нексколько функций с одним и тем же именем. Тип возвращаемого значение не влияет на перегрузку

```cpp
void sort(Array& Ar, int Key = 0); 
// Первые параметры не могут быть параметрами по умолчанию

sort(Mas); // Key = 0
```

### Лабораторная работа 1

Вьювер каркасной модели (3д фигура, можно 4). Вершины соединяются ребрами, получается каркасная модель. Надо поворачивать, переносить, масштабировать. Модель хранить в файле. Реализуем структурно. Оконный интерфейс. Домен интерфейс и домен это задача

## Лекция 4

* **struct** - все члены имеют уровень доступа public по умолчанию
* **union** - поля находятся в одной области памяти (небезопасно) *(не может быть базовым и производным классом)*
* **class** - все члены имеют уровен доступа private по умолчанию

```cpp
class <имяКласса> [:<списокБаз>]
{
private:               // Доступ только из других членов этого класса
    <списокЧленов>
protected:             // Доступ членам этого класса и производным от этого класса
    <списокЧленов>
public:                // Общий доступ
    <списокЧленов>     // Только методы
};
```

*Подход белого ящика (идем всегда от данных)*

### Если писать библиотеку для кого-то, то порядок другой:

1. `public`
2. `protected`
3. `private`

```cpp
// A.h
class A
{
private:
    int a;
public:
    int f();
};
```

```cpp
// A.cpp
[inline] int A::f()
{
    return this->a;
}
```

```cpp
A obj, *p;
obj.f();
p->f();
// .*, ->*
```

### Наследование

```cpp
class A
{
private:
    int a;
protected:
    int b;
public:
    int f();
};

class B : [private | protected | public] A 
// По умолчанию уровень доступа наследования private
{
private:
    int c;
protected:
    int d;
public:
    int g();
};
```

```cpp
B obj;
```

#### Доступ private

*При схеме private все члены класса наследуются с уровнем private.*

|private|protected|public
|---|---|---|
|a, c, b, f()|d|g()|

`g() не может обращаться только к a`

Класс ничего не знает о производных, поэтому `f()` не имеет доступ к `d` и `g()`

**Полная смена интерфейса**

#### Доступ protected

*Public члены базового класса получат доступ protected*

|private|protected|public
|---|---|---|
|a, c|f(), b, d|g()|

Производные классы от класса `B` будут иметь доступ к `f()`

#### Доступ public

*Все члены базового класса остаются при своих доступах*<br>
По пути расширения интерфейса (основная схема)

|private|protected|public
|---|---|---|
|a, c|b, d|f(), g()|

`using A::f()` - для методов private и protected для переопределения уровня доступа

### Конструктор

```cpp
<имяКласса>::<имяКласса>([<списокПараметров>])
    [:<разделИнициализации>]
{
    ...
}
```

**Конструктор вызывается не для объекта, а создает его.**

#### Модификаторы членов

```cpp
class A
{
private:
    int a;
    const int cb;
    static int sc; // Если это член класса, то надо ставить модификатор static
    const static int csd = 1;
public:
    A(int ia)
        : a(ia),   // OK! объект
          cb(ia),  // OK! константа
          sc(ia),  // NO! 
          csd(ia)  // Error! 
    {
        a = ia;   // OK!
        cb = ia;  // Изменять константу, когда объект создан нельзя (Error!)
        sc = ia;  // OK!
    }
};
```

В разделе инициализации обязательно инициализировать константы.

Инициализировать статические константы можно только при объявлении в классе

```cpp
int A::sc = 0; // рассматривается как инициализация
```

```cpp
class B
{
public:
    static int f(); // Статический метод может работать с полями класса
    int g() const;  // Метод можно перегрузить (для константного)
    int g();        // Для обычного объекта
};

B::f()
```

#### Приведение типов

`(<абстрактноеОписание>)<выражение>` - язык C<br>
`<тип>(<выражение>)` - язык C++

**Конструктор можно перегружать, он не может быть константным, статическим или виртуальным. Конструктор не наследуется**

#### Конструкторы создающиеся по умолчанию

Конструктор без параметров - **конструктор по умолчанию**<br>
**Конструктор копирования** - принимает const this

#### Конструктор копирования

По умолчанию: побайтово копирует<br>
Желательно всегда реализовывать

#### Конструктор переноса (познакомимся чуть позже)

#### Дилигирующий конструктор

```cpp
class A
{
public:
    A(int i) {...}
    A():A(0) {...} // Один конструктор вызывает другой конструктор
};
```

#### Наследование конструктора

```cpp
class A
{
public:
    A(int i);
};

class B : public A
{
public:
    using A::A; // Наследуются все конструкторы от A
};

B obj(2);       // Вызовется конструктор класса A
```

## Лекция 5

#### Конструктор с переменным числом параметров

```cpp
// Комплексное число
class Complex
{
private:
    double re, im;
public:
    Complex() : Complex(0, 0) {}
    Complex(double r) : Complex(r, 0) {}
    Complex(double r, double i);
    Complex(const Complex& c);          // Конструктор копирования
 // Complex(const Complex& c) = delete; // Удаление конструктора коп.
};
```

```cpp
Complex a(), v,
b1 = Complex(1.),           // Явный вызов конструктора
b2(2.),                     // Явный вызов конструктора
b3 = 3., b4 = {4.}, b5{5.}, // Неявный вызов конструктора (C++11)
c1 = Complex(6., 7.),
c2(8., 9.),
c3 = {10., 11.}, c4{12., 13.},
d1 = Complex(c1),           // Явный вызов конструктора копирования
d2(c2),                     // Явный вызов конструктора копирования
d3 = c3;                    // Неявный вызов конструктора копирования
```

```cpp
explicit // Запрещает неявный вызов конструктора
```

```cpp
class A
{
public:
    void f(int);
    void f(double) = delete; // Не будет неявного преобразования к int
    A(int);
    A() = default; // Конструктор по умолчанию
};
```

### Деструктор

```cpp
~Complex();
```

Не может быть константным. Можно вызвать явно, но **не надо**. Может быть виртуальным.

### Оператор new

```cpp
new <имяТипа>() // не только выделение памяти, но и создание объекта
new <имяТипа>[<размерность>] // Для нескольких объектов
```
### Оператор delete

```cpp
delete <указатель>      // Удаление одного
delete[] <указатель>    // Удаление нескольких
// Квадратные скобочки нужны для того, чтобы отработали деструкторы
```

```cpp
<тип> *<идефикатор> = new <имя>(); // []
```

### Наследование

В каких случаях создается иерархия классов:

1. Несколько классоб объединяем общей базой *(общая схема использования)*
2. Сходство между операциями
3. Два подмножества класса строятся в разной манере *(создаем производные классы)*
4. Класс фигурирует в двух несвязных между собой обсуждениях проекта

Если в базовом классе мы объявили метод, то в производном классе можно его объявить и он будет доминировать над базовым
база

Та база, которая находится в списке баз являются **прямыми базами**, прямая база может входить только один раз в производный класс

**Косвенная база** это прямая база прямой базы. Может входить в производный класс сколько угодно раз.

```
V   V
|   |
A   B
 \ /
  C
```

### Виртуальное наследование

```cpp
class V{...};
class A : virtual public V {...}; // Класс V входит только один раз
class B :         public V {...}; // Можно писать только один раз
class C : public A, public B {...}; // Очередность влияет
```

```
  V         V
 / \       / \
A   B     A   |
 \ /       \ /
  C         C
```

### Неоднозначности при множественном наследовании

```cpp
class A
{
public:
    int a;
    int (*b)();
    int f();
    int f(int);
    int g();
};

class B
{
    int a;
    int b;
public:
    int f();
    int g();
    int h();
    int h(int);
};

class C : public A, public B {};
```

```cpp
C c;
c.a = 1; // Ошибка
c.b();   // Ошибка
c.f();
c.f(1);
c.g = 2;
```

## Лекция 6

```cpp
class B. public V
{
protected:
    void _draw();
public:
    void draw()
    {
        v ::_draw();
        _draw();
    }
}
```

Испольуя указатель на класс, можно обратиться к любому полю.<br>
ООП - программирование без возможности выбора (switch)

```cpp
v *p = new A;
p->draw(); //вызовется класс В
```

```cpp
class A
{
public:
    virtual void f();
};
class B
{
public:
    void f() override/*обязательно писать*/ final/*в производных методах
    не сможем подменить этот метод*/; //подмена базового метода
};
```

Если класс абстрактный явно пишем модификатор abstruct. 

```cpp
A& index(A * vec, int i)
{
    return vec[i];
}
```

Объекты класса А имеют доступ ко всем членам класса В

```cpp
class A
{
}
class B
{
friend class A;
}
```

Дружба не наследуется (сын моего друга, мне не друг). Дружба не транзитивна.<br>
Можем сделать другом не весь класс, а только какой-то метод. 

```cpp
class A
{
public:
    int f();
}
class B
{
friend int A::f();
}
```

Нельзя!

```cpp
{
    A* p = new A;
    p->f();
    delete p;
}
```

### Перегрузка операторов

#### Нельзя: 

`. , * , :: , sizeof , typeid`

#### Можно:

`= , () , [] , -> , ->* , <знак>=`

Явное и неявное приведение типа это тоже оператор

```cpp
class Complex
{
private:
    double re, im;
public:
    Complex operator + (const Complex& C) const
    {
        return (this->re + C.re, this->im + C.im);
    }
};

Complex a, b;
c = a + b
```

Оператор `()` можно перегружать только один раз *(рассматривается только как бинарный, справа количество параметров (стек) не влияет)*

Оператор `->` будем часто использовать *(унарный оператор)* **Должен возращать указатель на объект**

```cpp
class A
{
public:
    int f();
};

class B
{
public:
    A* operator -> ();
};

B obj;
obj->f();
// (obj.operator->())->f();
```

```c
int f();
int (*pf)();
pf = f; // Имя любой функции это ее адрес в памяти
pf();   // Вызов функции по адресу
```

```cpp
int A::f();
int (A::*pf)();
pf = &A::f // взятие адреса для метода

A obj, *p = &obj;
(obj.*pf)(); // вызов указателя на функцию из объекта
(p->*pf)(); // вызов указателя на функцию из указателя
```

## Лекция 7

```cpp
class MyInt
{
private:
    int i = 0;
public:
    MyInt& operator++() // Префиксный ++оператор
    {
        ++i;
        return *this;
    }
    
    MyInt operator++(int) // Постфиксный оператор++
    {
        MyInt temp(i);
        i++;
        return temp;
    }
};

MyInt i;
++i; // MyInt& operator++()
i++; // MyInt operator++(int)
```


### Приведение типов

```cpp
class A
{
private:
    int i = 0;
public:
    operator bool()
    {
        return i == 0;
    }
};

A obj;
if (obj)
```

```cpp
class A
{
private:
    int i = 0;
public:
    explicit operator bool()
    {
        return i == 0;
    }
};

A obj;
if (obj)        // Нельзя
if (bool(obj))  // Только явно
```

### Временный объект

```cpp
Vector v1, v2, v3;
v1 = v2 + v3; // Создается временный объект 
```

### Копирование и перенос

```cpp
class Vector
{
private:
    double* ar;
    int count;
    static void copy(Vector& v1, const Vector& v2);
public:
    Vector(const Vector& v);                // Копирование
    Vector(Vector&& v);                     // Перенос
    Vector& operator= (const Vector& v);    // Копирование
    Vector& operator= (Vector&& v);         // Перенос
};

Vector::Vector(const Vector& v)
{
    copy(*this, v);
}

Vector::Vector(Vector&& v)
{
    this->count = v.count;
    this->ar = v.ar;
    v.ar = nullptr;
}

// a = b; копируем объект b в объект a
Vector& Vector::operator= (const Vector& v)
{
    delete[] this->ar;
    copy(*this, v);
}

// a = b + c; переносим временный объект b+c в объект a
Vector& Vector::operator= (Vector&& v)
{
    delete[] this->ar;
    this->count = v.count;
    this->ar = v.ar;
    v.ar = nullptr;
}

void Vector::copy(Vector& v1, const Vector& v2)
{
    v1.count = v2.count;
    v1.ar = new double[v1.count];
    for (int i = 0; i < v1.count; i++)
        v1.ar[i] = v2.ar[i];
}
```

### Обработка исключительных ситуаций

```cpp
try
{
    throw <тип>(<параметр>)
}
catch(<тип>& <переменная>)
```

```cpp
class A
{
public:
    void f() noexcept
    // noexcept(true)
    // noexcept(false)
    // throw(<тип>) функция может сгенерировать искл. ситуацию
};
```

### std::exception

```cpp
class MyException : public std::exception
{
public:
    virtual const char* what(const char* msg) const noexcept;
};
```


### Шаблоны

```cpp
template<сlass | typename <параметр> >
```

```cpp
template <typename Type>
unsigned length(FILE* stream)
{
    return filelenght(fileno(stream)) / sizeof(Type);
}

size = length<double>(stream);
```

## Лекция 8

Можно также создавать шаблоны классов

```cpp
// Первый аргумент шаблона тип данных, второй - размер
template <typename T, size_t n>
class Vector
{
private:
    T ar[n];
    size_t size = n;
public:
    Vector();
    size_t count();
    ...
};

template <typename T, size_t n>
Vector<T, n>::Vector() {}
```

Все шаблонные методы мы вынуждены описывать в **заголовочном файле**, поскольку только **во время использования** мы можем скомпилировать файл, узнав какой тип данных будем использовать

**Базовый класс** - нешаблонный

### Полная или частичная специализация

#### Полная специализация

```cpp
template <>
class Vector<double, 5>         // Пример полной специализации
{};
```

#### Создание объекта

```cpp
Vector<int, 2> v;
```

Шаблон не накладывает никаких ограничений на типы данных

#### Частичная специализация

```cpp
template <typename T1, typename T2>
class A {...};

template <typename T>
class A<T, T> {...};

template <typename T>
class A<T, int> {...};

template <typename T1, typename T2>
class A<T1*, T2*> {...};
```

Проверка начинается со специализаций

```cpp
A<int, float> a1;       // Ни одна специализация не подошла
A<float, float> a2;     // A<T, T>
A<float, int> a3;       // A<T, int>
A<int*, float*> a4;     // A<T1*, T2*>
A<int, int> a5;         // Неоднозначность (Error) (A<T, T>, A<T, int>)
A<int*, int*> a6;       // Неоднозначность (Error) (A<T, T>, A<T1*, T2*>)
```

### Параметры шаблона по умолчанию

```cpp
template <typename T1, typename T2 = float>
classA {...};

A<float> a1;
a<float, int> a2;
```

Параметры по умолчанию должны быть **последними** в списке шаблонов

### Шаблоны с переменным числом параметров

```cpp
template<typename T1, typename ...Args>
T sum(T v1, T v2, Args... args)
{
    return v2 + sum(v2, args...);
}

template <typename T>
T sum (T v)
{ return v; }
```

```cpp
template <typename T1, template T2>
// Будет возращать тип выражения x + y
auto sum (T1 x, T2 y) -> decltype(x + y)
{
    return x + y;
}

auto obj = <выражение>;
```

### Пространство имени

```cpp
namespace <имя>
{
    int f();
}
```

#### Обращение 

```cpp
<имя>::f();
```

#### Определение пространства имен

```cpp
using namespace <имя>;
f();
```

```cpp
{
    A* p = new A;
    p->f();
    delete p;
}
```

### Оболочка указателей

```cpp
{
    Holder <A> obj(new A);
    obj->f();
}
```

3 умных указателя в c++11

### Хранители (умные указатели)

```cpp
unique_ptr<тип> // Легкая прозрачная оболочка
```

`unique_ptr` обеспечивает строгое владение указателя *(он за него отвечает)*<br>
Можно передать указатель другому хранителю *(не обязательно `unique_ptr`)*

```cpp
std::unique_ptr<A> obj(new A);
std::unique_ptr<A> obj2(std::move(obj1)); // Передача владения
obj1 = obg2 // Нельзя!
pbj2 = std::move(obj1);
```

Перегружены операторы `->, *, bool(), []`

#### Совместное владение


```cpp
shared_ptr<A> obj(new A) // Позволяет копирование
```

Создать библиотечный шаблоный контейнерный класс(4 варианта)

1. Вектор математический
2. Множество (каждый элемент уникален)
3. Список прямого доступа
4. Матрица

`Nжурнала - 1 % 4 + 1`

1. Контейнерный класс
2. Операции
3. Просматривать содержимое в контейнере по итератору a[i]
4. Интерфейс должен быть избыточным

## Лекция 9

#### Мягкое владение

```cpp
weak_ptr<A>
```

### Список

```cpp
struct List
{
    Node* First, *Last;
};

struct Iterator
{
    Node* Current;
};
```

### Шаблоны и паттерны проектирования

* Порождающие
* Поведения
* Структурные


### Порождающие паттерны

#### Методы решения проблем

* **Фабричный метод** - создать объект

```cpp
class AbstractCreator
{
public:
    virtual unique_ptr<Product>;
    CreateProduct() = 0;
};

template <typename TProd>
class ConCreator : public AbstractCreator
{
public:
    virtual unique_ptr<Product> CreateProduct() override
    {
        return unique_ptr<Product>(new Tprod());
    }
};
```

```cpp
class Creator
{
public:
    shared_ptr<Product> GetProduct();
protected:
    virtual shared_ptr<Product> CreateProduct() = 0;
private:
    shared_ptr<Product> product;
};

shared_ptr<Product> Creator::GetProduct()
{
    if (product)
        product = CreateProduct();
    return product;
}
```

* **Абстрактная фабрика** - создавать объекты разных классов, но связанных между собой

* **Прототип** - реализуют метод, который называют `clone`, на основе которого создают новый объект

```cpp
class Prototype
{
public:
    virtual unique_ptr<Prototype> Clone() = 0;
};
```

* **Строитель** - 

## Лекция 9

```cpp
template<typename Type>
class Singleton
{
public:
    static Type& instance()
    {
        return *myInstance > myInstance(myInstance = new Type());
    }
    Singleton() = delete;
    Singleton<Type>& operator=(const Singleton<Type>&) = delete;
    Singleton(const Singleton<Type>&) = delete;
private:
    static Type* myInstance = nullptr;
};
```

## Лекция 10

```
Command
Execute()
^
|
|-----------------
|                |
ConCom1         ConComN
Execute(). ...  Execute()
```

```cpp
class Command
{
public:
    virtyal void execute() = 0;
};

template <typename Receiver>
class SimpleCom : public Command
{
public:
    typedef void (Receiver::*Action)();
    SimpleCom(shared_ptr<Receiver> r, Action a);
    void execute() override
    {
        ((*_r).*_a)();
    }
private:
    shared_ptr<Receive> _r;
    Action _a;
};
```

### Цепочка обязаностей

Что-то выполнили и перешли по цепочки к следующему. Есть базовый класс, задача которого вызвать действия производного класса, который выполняет действия и следующий переход (список в структуре класса)


```
Handler
Handle()
^
|
|
Handler1
Handle() ...
```

```cpp
class Handler
{
public:
    void add(shared_ptr<Handler> elem)
    {
        if (next)
            next->add(elem);
        else
            next = elem;
    }
    
    virtual void handle()
    {
        if (next)
            next->handle();
    }
private:
    shared_ptr<Handler> next;
};

class Handler1 : public Handler
{
public:
    void handle() override
    {
        if (brew services start httpd)
    }
};
```

### Подписчик-издатель

```
Object1         --->    Mediator    --->    Object2
Interface1()            Retrive()           Interface2()
                            ^
                            |
                            |
                          Client
```


### Паттерн состояния

Держит состояние объекта, используется в 3 лр, Входит в **КМС** - конечная модель состояния - паттерн проектирования

### Паттерн визитер

Посетитель

### Паттерн итератор

### Паттерн индексатор

### Паттерн интерпретатор


## Объектно-ориентированный анализ

### Этапы

1. Анализ
2. Проектирование
3. Эволюция
4. Модификация

Можно вернуться на предыдущий этап

1. Схема доменов
2. Проектная матрица
3. Модель связей подсистем
4. Модель взаимодействия подсистем
5. Модель доступа и подсистем
6. Информационная модель
7. Описани классов и атрибутов
8. Описание связей
9. Модель взаимодействия объектов
10. Состояние объекта
11. Список событий
12. Модель доступа к объекту
13. Таблица процессов состояний
14. Модель (переходов) состояний

4 лабораторная - 1 работа, реализовать объектами, построить модель(выделить сущности, формализация (отношения), посредники). Задача рассмотрения одного объекта, но возможно появление нескольких, даже групп

## Лекция 11

### Объектно-оринтированный анализ

#### Подход белого ящика

1. Выделение сущностей физических объектов
2. Выделение атрибутов

Любая характериска, которую мы выделяем, абстрагируется **как отдельный атрибут**.

**Идентификатор** - это множество из одного или нескольких атрибутов, с помощью которых можно четко идентифицировать объект.

#### Каждая сущность на информационной моделе 

|<Номер> <Имя> (<Короткая запись имени>)|
|---|
|*<идентификатор><br>-<br>-<br>-<br>-<br>-|


#### Атрибуты

1. **Описательные** - представляют факты, присущие каждому объекту данной выделенной сущности
2. **Указывающие** - идентификатор или часть идентификатора
3. **Вспомогательные**
    * Атрибуты, возникающие в результате формализации связей между сущностями
    * Атрибуты состояния

##### Описательный атрибут

1. Описать причину по которой ы выделили этот атрибут
2. Важно кто задает или использует этот атрибут

##### Указывающий атрибут

1. Важно кто задает значение

##### Вспомогательный атрибут



##### На атрибуты накладываются правила 

1. **Любой объект** в **любой момент времени** для каждого атрибута должен иметь значение и оно должно быть одно
2. Атрибут должен быть простым *(не содержать внутренней структуры)*
3. **Если объект имеет составной идентификатор:** каждый атрибут, который является частью идентификатора, должен быть характеристикой этого объекта
4. Каждый атрибут, не являющийся частью индентификатора, представляет характеристику объекта, указанного идентификатором

#### Связи

**Связь** - это абстракция набора отношений, которые возникают между объектами в реальном мире

Учит

|1 Преподаватель (П)|
|---|
|*Id препод.<br>-Имя<br>-Стаж<br>-Ученая степень<br>-Звание|

|<br>
| R1<br>
|<br>

Учится

|2 Студент (С)|
|---|
|*Id студ.<br>-Имя<br>-N студ.<br>-Пол|

1. **Безусловные связи** - и один объект, и другой участвуют в связи
2. **Условные связи** - объект в связи может не участвовать
3. **Биусловные связи** - оба объекта могут не участвовать

##### Множественная связь

1. Один к одному
2. Один ко многим
3. Многие ко многим

В результате получаем 9 связей + нет связи = 10 видов

1. Идентификатор
2. Формулировка связи каждому объекту
3. Вид связи (Условность, множественность)
4. Обосновать, зачем эта связь
5. Как была формализована связь

**Если связь 1 к 1, то кто-то должен держать эту связь, добавляем вспомогательный атрибут**

|1 Муж (М)||2 Жена (Ж)|
|---|---|---|
|...<br>-ФИО жены(R10)|<center>R10</center>--------------|*ФИО|

**Связь один ко многим реализуется через многих**

Один <---- Многие

**Многие ко многим: добавляется ассоциативный объект (объект, который отвечает за связь)**

|1 Квартира (К)||2 Владелец (В)|
|---|---|---|
|* Id кварт,<br>-Адрес<br>-Площадь<br>-Этаж|<center>R100</center><br><center><<————>></center><br><center>`|`</center>|* Id влад.<br>-Возраст<br>-Пол|

|3 Владение (Вл)|
|---|
|* Id квартиры (R100)<br>* Id владельца (R100)<br>-Доля владения<br>-Дата начала владения|

**Композиция связи** - связь являеся слествием других связей

`R3 = R1 + R2`

### Подклассы и суперклассы

|1 Бак (Б)|
|---|
|* Id бака<br>|

+R1000

|||
|---|---|
|* Id бака (R1000)|* Id бака (R1000)|


### Модель Мура

* Выделяем множество состояний, в которых он может находиться 
* Множество событий, при котором изменяются состяния
* Правила перехода, в какое новое состояние он перейдет при возникновении в данном состоянии события
* Вспомогательный атрибут состояний
* Действие состояния, каждому состоянию ставим в соотсветствие действие, которое выполняется при переходе объекта в состояние

## Лекция 12

**Состояние объекта** - это набор правил линий поведения

* Состояние создания
* Заключительное
    * Объект становится неподвижным
    * Объект удаляется

Выделяем значение события (короткая фраза о том, что происходит с объектом)

Те события, которые переводит объект из одного состояния в другое, должны держать в себе **идентификатор объекта** (и нести одни и те же данные)

**Действие** - это деятельность или оперрация, которая должна быть выполнена когда объект перешел в состояние

### Что может делать:

* Выполнять вычисления
* Порождать события *(для себя, объектов класса, так и для любых других объектов, порождать события вне области анализа)*
* Выполнять все действия с таймером *(создавать, удалять, устанавливать, запускать и сбрасывать, считывать время)*
* Действие может работать с атрибутами своего объекта, класса или других классов

### Обязательно

* Любое действие не должно оставлять противоречивости атрибутов и связей *(если связь 1к1, то объект удаляется и создается объект нового класса)*
* Задача изменения атрибута состояния

### Описание действия

* Нарисовать схему или алгоритм, если оно большое
* Если небольшое, то можем написать на псевдокоде на модели состояния под состоянием

Событие никогда не теряется, оно им принимается, когда объект не выполняет никаких действий.
В каждый момент времени выполняется одно действие, но действия разных объектов в данный момент времени могут выполняться одновременно

Это **асинхронная схема взаимодействия**

### Правило перехода

Для контроля перехода мы строим **Таблицу перехода состояний**
Каждая строка - возможное состояние объектов
Столбец - событие

|           | Событие  | Событие |
| --------- | -------- | ------- |
| Состояние |          | 2       |
| Состояние | $\times$ | $-$     |

#### 3 возможных перехода

* Переход в какое-то состояние
* Если объект не реагирует, то ставится $-$
* Если выполниться не может, ставим $\times$
    * Можно обработать как исключительную ситуацию
    * Обработка и переход в ошибочное состояние

### 3 лабораторная

Паттерн подписчик-издатель

Смоделировать работу лифта
Выделяем несколько объектов:

* Кабина лифта
* Двери лифта
* Лифт
* Блок управления
* Мб умный лифт знает сколько пассажиров

Есть разные объекты и возникают связанные жизненные циклы. Состояние одного объекта связано с состоянием другого *(неполное соответствие)* 

Состояния связаны и определяют друг друга:

* Выделяем несколько объектов
* Строим модели состояний
* Смотрим какие события приводят к состояниям этого объекта или других

`C++ Qt` на сигналах и слотах, можно использовать `C#` 

### Делегаты

```cpp
// C++ cli
// ref - динамическое размещение
// value - статическое размещение
// ^ - указатель из управляемой кучи
delegate void Eventhandle2(Object^ source, double d);

public ref class Manager // Издатель
{
public:
	event Eventhandler^ OnHandler;
    void Method()
    {
        OnHandler(this, 100)
    }
};

public ref class Watcher // Подписчик
{
public:
	Watcher (Manager^ m)
    {
    	m->OnHandler += gcnew Eventhandler(this, &Watcher::f);
    }
   
    void f(Object^ source, double d) {...}
};

// Main
{
    Manager^ m = gcnew Manager();
    Watcher^ w = gcnew Watcher(m);
    m->Method();
}
```

## Лекция 13

| Таймер (T)                                                |
| --------------------------------------------------------- |
| *Id таймера<br>- Время<br>- Id объекта<br>- Метка события |

1. Установить
2. Отсчет времени
3. Подача сигнала
4. Сброс

|                   | T1   | T2   | T6   | T7   |
| ----------------- | ---- | ---- | ---- | ---- |
| 1. Установка      | —    | 4    | 2    | X    |
| 2. Отсчет времени | —    | 4    | 2    | 3    |
| 3. Подача сигнала | —    | 4    | X    | X    |
| 4. Сброс          | 1    | 4    | X    | X    |

```
if это.время = 0 then Порождает Т7(Id T)
else
	это.время := это.время - 1
	if это.время = 0 then Порождает T7(Id T)
	else Порождает T6(Id T)
```

## Лекция 14

* Аксессоры
* Генераторы событий
* Преобразования
* Проверка

Повторяющиеся действия делать через условный процесс



| Id проц | Тип  | Назначение процесса | Где использовать |
| ------- | ---- | ------------------- | ---------------- |
|         | а    |                     |                  |

Выделив аксессор, строим диаграмму: модель доступа к объекту

Каждый объект риусется в вытянутом овале

```
-----------     n1   -----------
|Объект A|--------->|Объект Б|
-----------          -----------
```

Объект A использует аксессор объекта B

### Домены и подсистемы

**Домен** - отдельный реальный, гипотетический или абстрактный мир, населенный набором объектов, которые ведут себя характерными для домена правилами поведения 

*Разбиваем задачу на домены*

* **Прикладной домен** - домен задачи, предметная область того, что мы решаем
* **Сервисные домены** - набор средств, которые мы используем: библиотеки, то, что нам предоставляет какой-то функционал
* **Архитектурный домен** - задает общий механизм и структуру управления в нашем ПО. *Как правило в основу включается паттерн шаблонный метод*
* **Домен реализации** - функционал, который обеспечивается операционной системой 

Если один домен использует механизмы другого, то между ними паттерн **мост**. Паттерн, который использует - **клиент**, который предостовляет - **сервер**. Клиент рассматривает мост как набор предложений, ему все равно кто реализует, а сервер - как набор требований, ему все равно кому предоставлять.

Если количество классов в домене >50, то с таким доменом тяжело работать, такой домен разбиваем на **подсистемы**

#### Три диаграммы:

* Модель связи подсистем *(Сущность - связь, только не объекы, а подсистемы)*
* Модель доступа к подсистеме *()*

Лр 5

Подготовить диаграммы, выполнить моделирование. Выделить сущности, выделить атрибуты, связи. Диаграмма сущность - связь

Выделить жизненные циклы для объектов, построить модель, строить канал управления

Расписываем действия состояний, строим ДПС, выделяем аксессорные связи

Псевдокод

Любой бытовой прибор у которого выделяется жизненный цикл

 ## Лекция 15

### Архитектурный домен

#### Сущности

1. Активный экземпляр
2. КМС
3. Переход

#### Переход
